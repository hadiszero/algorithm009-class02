# Trie树
## 特性：

trie树又称前缀树或字典树;
根节点对应空字符串;
键通常是字符串;
键不是直接保存在节点中节点在树的位置决定的;
一个节点的所有子孙都有相同的前缀;

## 基本结构：

是一种树形结构，通常应用于统计和排序大量的字符串（搜索引擎系统用于本文词频统计）；
优点：最大限度的减少字符串比较，查询效率比哈希表高；

## 基本性质

节点本身不存完整单词;
从根结点到某一结点，路径上经过的字符串连接起来，为该结点对应的字符串；
每个结点的所有子结点路径代表的字符都不相同。

## 核心思想
trie树的核心思想是空间换时间;
利用字符串的公共前缀来将低查询时间的开销 以达到提高效率的目的;
实现trie树

## 搜索单词：
方法：insert、startsWidth、search;
TrieNode:isEnd：boolean（是否为单词的尾部）、links：Arrray(26)（连接下一个节点）;
Trie：root:new TrieNode;
!代码.
时间复杂度
添加:O(n)-->n：单词的长度; 查询:O(n)



# 并查集
## 适用场景
组团、配对问题


## 基本操作
makeSet(s):建立一个新的并查集，其中包含s个单元素集合。

unionSet(X,y):把元素X和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并;

find(x):找到元素x所在的集合的代表，该操作也可以用于判断两个元素是否位于同一个集合，只要将它们各自的代表比较一下就可以了。

每个元素有个parent数组指向自己;

查询：通过parent找上一级parent,依次类推查找最顶的parent元素;

合并：通过两个集合的顶部parent元素(a和b两个集合，a的parent指向b或者b的parent指向a);


## 路径压缩

将所有元素指向同一个元素的parent

### 代码模板

class UnionFind{
    constructor(n){
        this.count=n;
        this.parent=new Array(n);
        for(let i=0;i<n;++i){
            this.parent[i]=i;
        }
    }
    find(p){
        let parent=this.parent;
        while(p!=parent[p]){
            parent[p]=parent[parent[p]];
            p=parent[p];
        }
        return p;
    }
    union(p,q){        
        let rootP=this.find(p);
        let rootQ=this.find(q);
        if(rootP===rootQ)return;
        this.parent[rootP]=rootQ;
        this.count--;
    }  
}


# 高级搜索
## 剪枝

### 双向BFS

### 启发式搜索(A*)

# 总结

朴实搜索 -->(初级搜索)
优化方式： 不重复、剪枝

### 搜索方向：
DFS:深度优先搜索
BFS:广度优先搜索
双向搜索、启发式搜索
回溯法: 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确解答的时候，它将取消上一步甚至是几步的计算，再通过其它的可能分步解答再次尝试寻找问题的答案。
回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：

找到一个可能存在的正确的答案；
在尝试了所有可能的分步方法后宣告该问题没有答案； 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。
高级树、AVL树和红黑树
二叉搜索树保证性能的关键是：保证二维维度-->左右子树结点平衡

### 平衡二叉树的实现种类：
2–3 tree
AA tree
AVL tree：AVL树
B-tree:B树
Red–black tree：红黑树
Scapegoat tree：替罪羊树
Splay tree：伸展树
Treap：树堆
Weight-balanced tree：加权平衡树
AVL树

Blance Factor(平衡因子)：左子树的高度减去右子树的高度（有时相反） --> 平衡因子值为{-1,0,1}
通过旋转操作来进行平衡（四种）!旋转操作图
左旋
右旋
左右旋
右左旋
### 缺点： 结点需要存额外信息（平衡因子）且调整次数频繁（旋转操作）
红黑树(近似平衡二叉树)

红黑树是一种近似平衡的二叉搜索树，能确保任何一个结点的左右子树的高度差小于两倍。
从根结点到叶子结点的最长可能路径不多于最短的可能路径的两倍长。


### 性质：
根结点是黑色；
每个叶子结点（空结点）是黑色的。
不能有相邻接的两个红色结点；
从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。

## 总结：
AVL树比红黑树提供更快的查询操作。（AVL树属于严格的平衡二叉搜索树）;
红黑树提供了比AVL更快的删除和插入操作。（红黑树的旋转操作比AVL少）;
AVL树需要存额外的factors或者heights比红黑树（0/1 -->表示红黑）更多点，所以需要更多的内存。
读操作比较多使用AVL;